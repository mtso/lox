// begin utils

class Object { }

class List {
  init() {
    this._items = Object();
    this._count = 0;
  }
  add(item) {
    this._items.(this._count) = item;
    this._count = this._count + 1;
  }
  get(i) { return this._items.(i); }
  size() { return this._count; }
  forEach(callback) { for (var i = 0; i < this._count; i = i + 1) callback(this._items.(i)); }
  isEmpty() { return this.size() == 0; }
  // Stack ADT.
  push(item) { this.add(item); }
  peek() { return this._items.(this._count - 1); }
  pop() {
    if (this._count <= 0) return nil;
    this._count = this._count - 1;
    var last = this._items.(this._count);
    this._items.(this._count) = nil;
    return last;
  }
}

class Map {
  init() {
    this._items = Object();
    this._count = 0;
  }
  set(key, value) {
    if (this._items.(key) == nil and value != nil) this._count = this._count + 1;
    if (this._items.(key) != nil and value == nil) this._count = this._count - 1;
    this._items.(key) = value;
  }
  get(key) { return this._items.(key); }
  size() { return this._count; }
}

fun split(hay, needle) {
  var needleLen = strlen(needle);
  var len = strlen(hay);
  var result = Object();
  var start = 0;
  var end = 0;
  var count = 0;
  for (var i = 0; i < len - needleLen + 1; i = i + 1) {
    var potential = strslice(hay, i, i + needleLen);
    if (potential == needle) {
      result.(count) = strslice(hay, start, end);
      start = end + needleLen;
      end = start;
      i = i + needleLen - 1;
      count = count + 1;
    } else {
      end = end + 1;
    }
  }
  result.(count) = strslice(hay, start, len);
  result.len = count + 1;
  return result;
}

// end utils

// begin ast
class Expr {
  accept(visitor) {
    print("Not implemented!");
  }
}
class Assign {
  init(name, value) {
    this.name = name;
    this.value = value;
  }
  accept(visitor) {
    return visitor.visitAssignExpr(this);
  }
  getClassName() {
    return "Assign";
  }
}
class Binary {
  init(left, operator, right) {
    this.left = left;
    this.operator = operator;
    this.right = right;
  }
  accept(visitor) {
    return visitor.visitBinaryExpr(this);
  }
  getClassName() {
    return "Binary";
  }
}
class Call {
  init(callee, paren, arguments) {
    this.callee = callee;
    this.paren = paren;
    this.arguments = arguments;
  }
  accept(visitor) {
    return visitor.visitCallExpr(this);
  }
  getClassName() {
    return "Call";
  }
}
class Get {
  init(object, name) {
    this.object = object;
    this.name = name;
  }
  accept(visitor) {
    return visitor.visitGetExpr(this);
  }
  getClassName() {
    return "Get";
  }
}
class Grouping {
  init(expression) {
    this.expression = expression;
  }
  accept(visitor) {
    return visitor.visitGroupingExpr(this);
  }
  getClassName() {
    return "Grouping";
  }
}
class Literal {
  init(value) {
    this.value = value;
  }
  accept(visitor) {
    return visitor.visitLiteralExpr(this);
  }
  getClassName() {
    return "Literal";
  }
}
class Logical {
  init(left, operator, right) {
    this.left = left;
    this.operator = operator;
    this.right = right;
  }
  accept(visitor) {
    return visitor.visitLogicalExpr(this);
  }
  getClassName() {
    return "Logical";
  }
}
class Set {
  init(object, name, value) {
    this.object = object;
    this.name = name;
    this.value = value;
  }
  accept(visitor) {
    return visitor.visitSetExpr(this);
  }
  getClassName() {
    return "Set";
  }
}
class This {
  init(keyword) {
    this.keyword = keyword;
  }
  accept(visitor) {
    return visitor.visitThisExpr(this);
  }
  getClassName() {
    return "This";
  }
}
class Unary {
  init(operator, right) {
    this.operator = operator;
    this.right = right;
  }
  accept(visitor) {
    return visitor.visitUnaryExpr(this);
  }
  getClassName() {
    return "Unary";
  }
}
class Variable {
  init(name) {
    this.name = name;
  }
  accept(visitor) {
    return visitor.visitVariableExpr(this);
  }
  getClassName() {
    return "Variable";
  }
}
class Stmt {
  accept(visitor) {
    print("Not implemented!");
  }
}
class Block {
  init(statements) {
    this.statements = statements;
  }
  accept(visitor) {
    return visitor.visitBlockStmt(this);
  }
  getClassName() {
    return "Block";
  }
}
class Class {
  init(name, methods) {
    this.name = name;
    this.methods = methods;
  }
  accept(visitor) {
    return visitor.visitClassStmt(this);
  }
  getClassName() {
    return "Class";
  }
}
class Expression {
  init(expression) {
    this.expression = expression;
  }
  accept(visitor) {
    return visitor.visitExpressionStmt(this);
  }
  getClassName() {
    return "Expression";
  }
}
class If {
  init(condition, thenBranch, elseBranch) {
    this.condition = condition;
    this.thenBranch = thenBranch;
    this.elseBranch = elseBranch;
  }
  accept(visitor) {
    return visitor.visitIfStmt(this);
  }
  getClassName() {
    return "If";
  }
}
class Function {
  init(name, params, body) {
    this.name = name;
    this.params = params;
    this.body = body;
  }
  accept(visitor) {
    return visitor.visitFunctionStmt(this);
  }
  getClassName() {
    return "Function";
  }
}
class Print {
  init(expression) {
    this.expression = expression;
  }
  accept(visitor) {
    return visitor.visitPrintStmt(this);
  }
  getClassName() {
    return "Print";
  }
}
class Return {
  init(keyword, value) {
    this.keyword = keyword;
    this.value = value;
  }
  accept(visitor) {
    return visitor.visitReturnStmt(this);
  }
  getClassName() {
    return "Return";
  }
}
class Var {
  init(name, initializer) {
    this.name = name;
    this.initializer = initializer;
  }
  accept(visitor) {
    return visitor.visitVarStmt(this);
  }
  getClassName() {
    return "Var";
  }
}
class While {
  init(condition, body) {
    this.condition = condition;
    this.body = body;
  }
  accept(visitor) {
    return visitor.visitWhileStmt(this);
  }
  getClassName() {
    return "While";
  }
}
class Visitor {
  visitAssignExpr(expr) { print("visitAssignExpr not implemented! " + str(this)); }
  visitBinaryExpr(expr) { print("visitBinaryExpr not implemented! " + str(this)); }
  visitCallExpr(expr) { print("visitCallExpr not implemented! " + str(this)); }
  visitGetExpr(expr) { print("visitGetExpr not implemented! " + str(this)); }
  visitGroupingExpr(expr) { print("visitGroupingExpr not implemented! " + str(this)); }
  visitLiteralExpr(expr) { print("visitLiteralExpr not implemented! " + str(this)); }
  visitLogicalExpr(expr) { print("visitLogicalExpr not implemented! " + str(this)); }
  visitSetExpr(expr) { print("visitSetExpr not implemented! " + str(this)); }
  visitThisExpr(expr) { print("visitThisExpr not implemented! " + str(this)); }
  visitUnaryExpr(expr) { print("visitUnaryExpr not implemented! " + str(this)); }
  visitVariableExpr(expr) { print("visitVariableExpr not implemented! " + str(this)); }
  visitBlockStmt(stmt) { print("visitBlockStmt not implemented! " + str(this)); }
  visitClassStmt(stmt) { print("visitClassStmt not implemented! " + str(this)); }
  visitExpressionStmt(stmt) { print("visitExpressionStmt not implemented! " + str(this)); }
  visitIfStmt(stmt) { print("visitIfStmt not implemented! " + str(this)); }
  visitFunctionStmt(stmt) { print("visitFunctionStmt not implemented! " + str(this)); }
  visitPrintStmt(stmt) { print("visitPrintStmt not implemented! " + str(this)); }
  visitReturnStmt(stmt) { print("visitReturnStmt not implemented! " + str(this)); }
  visitVarStmt(stmt) { print("visitVarStmt not implemented! " + str(this)); }
  visitWhileStmt(stmt) { print("visitWhileStmt not implemented! " + str(this)); }
}
// end ast

class TokenType {
  init() {
    this.LEFT_PAREN = "LEFT_PAREN";
    this.RIGHT_PAREN = "RIGHT_PAREN";
    this.LEFT_BRACE = "LEFT_BRACE";
    this.RIGHT_BRACE = "RIGHT_BRACE";
    this.COMMA = "COMMA";
    this.DOT = "DOT";
    this.MINUS = "MINUS";
    this.PLUS = "PLUS";
    this.SEMICOLON = "SEMICOLON";
    this.SLASH = "SLASH";
    this.STAR = "STAR";
    // One or two character tokens.
    this.BANG = "BANG";
    this.BANG_EQUAL = "BANG_EQUAL";
    this.EQUAL = "EQUAL";
    this.EQUAL_EQUAL = "EQUAL_EQUAL";
    this.GREATER = "GREATER";
    this.GREATER_EQUAL = "GREATER_EQUAL";
    this.LESS = "LESS";
    this.LESS_EQUAL = "LESS_EQUAL";
    // Literals.
    this.IDENTIFIER = "IDENTIFIER";
    this.STRING = "STRING";
    this.NUMBER = "NUMBER";
    // Keywords.
    this.AND = "AND";
    this.CLASS = "CLASS";
    this.ELSE = "ELSE";
    this.FALSE = "FALSE";
    this.FUN = "FUN";
    this.FOR = "FOR";
    this.IF = "IF";
    this.NIL = "NIL";
    this.OR = "OR";
    this.PRINT = "PRINT";
    this.RETURN = "RETURN";
    this.SUPER = "SUPER";
    this.THIS = "THIS";
    this.TRUE = "TRUE";
    this.VAR = "VAR";
    this.WHILE = "WHILE";
    // EOF.
    this.EOF = "EOF";
  }
}

var TT = TokenType();

class Token {
  init(type, lexeme, literal, line) {
    this.type = type;
    this.lexeme = lexeme;
    this.literal = literal;
    this.line = line;
  }

  toString() {
    return str(this.type) + " '" + str(this.lexeme) + "' " + str(this.literal);
  }
}

class Result {
  init(ok, value) {
    this.ok = ok;
    this.value = value;
  }

  ifOk(mapper) {
    if (this.ok) return Result(true, mapper(this.value));
    else return this;
  }
}

class Error {
  init(code, message) {
    this.code = code;
    this.message = message;
  }
}

class ParseError < Error {
  init() {
    super.init("ParseError", nil);
  }
}

class RuntimeError < Error {
  init(token, message) {
    super.init("RuntimeError", message);
    this.token = token;
  }
}

class ReturnState < Error {
  init(value) {
    super.init("ReturnState", nil);
    this.value = value;
  }
}

fun ok(value) {
  return Result(true, value);
}

fun err(value) {
  return Result(false, value);
}

class Lox {
  init() {
    this.hadError = false;
    this.hadRuntimeError = false;
  }

  error(line, message) {
    this.report(line, "", message);
  }

  errorToken(token, message) {
    if (token.type == TT.EOF) this.report(token.line, " at end", message);
    else this.report(token.line, " at '" + token.lexeme + "'", message);
  }

  runtimeError(error) {
    eprint(error.message + "\n[line " + str(error.token.line) + "]");
    this.hadRuntimeError = true;
  }

  report(line, where, message) {
    eprint("[line " + str(line) + "] Error" + str(where) + ": " + message);
    this.hadError = true;
  }
}

var LOX = Lox();

class Environment {
  init(enclosing) {
    this.enclosing = enclosing;
    this.values = Map();
    this.defines = Map();
  }

  get(name) {
    if (this.defines.get(name.lexeme) == true) return ok(this.values.get(name.lexeme));
    if (nil != this.enclosing) return this.enclosing.get(name);
    return err(RuntimeError(name, "Undefined variable '" + name.lexeme + "'."));
  }

  assign(name, value) {
    if (this.defines.get(name.lexeme) == true) return ok(this.values.set(name.lexeme, value));
    if (nil != this.enclosing) return this.enclosing.assign(name, value);
    return err(RuntimeError(name, "Undefined variable '" + name.lexeme + "'."));
  }

  define(name, value) {
    this.defines.set(name, true);
    this.values.set(name, value);
  }

  getAt(distance, name) {
    return ok(this.ancestor(distance).values.get(name));
  }

  assignAt(distance, name, value) {
    return ok(this.ancestor(distance).values.set(name.lexeme, value));
  }

  ancestor(distance) {
    var environment = this;
    for (var i = 0; i < distance; i = i + 1) {
      environment = environment.enclosing;
    }
    return environment;
  }
}

class LoxCallable {
  arity() {
    print("LoxCallable::arity(0) not implemented! " + str(this));
  }
  call(interpreter, arguments) {
    print("LoxCallable::call(2) not implemented! " + str(this));
  }
  isCallable() { return true; }
}

class LoxFunction < LoxCallable {
  init(declaration, closure, isInitializer) {
    this.declaration = declaration;
    this.closure = closure;
    this.isInitializer = isInitializer;
  }

  bind(instance) {
    var environment = Environment(this.closure);
    environment.define("this", instance);
    return LoxFunction(this.declaration, environment, this.isInitializer);
  }

  call(interpreter, arguments) {
    var environment = Environment(this.closure);
    for (var i = 0; i < this.declaration.params.size(); i = i + 1) {
      environment.define(this.declaration.params.get(i).lexeme,
          arguments.get(i));
    }

    var result = interpreter.executeBlock(this.declaration.body, environment);
    if (!result.ok) {
      var error = result.value;
      if (error.code == "ReturnState") {
        return ok(error.value);
      } else {
        return result;
      }
    }

    if (this.isInitializer) return this.closure.getAt(0, "this");
    return ok(nil);
  }

  arity() {
    return this.declaration.params.size();
  }

  toString() {
    return "<fn " + this.declaration.name.lexeme + ">";
  }
}

class LoxClass < LoxCallable {
  init(name, methods) {
    this.name = name;
    this.methods = methods;
  }

  findMethod(name) {
    if (this.methods.get(name) != nil) {
      return this.methods.get(name);
    }
    return nil;
  }

  toString() {
    return this.name;
  }

  call(interpreter, arguments) {
    var instance = LoxInstance(this);
    var initializer = this.findMethod("init");
    if (nil != initializer) {
      var result = initializer.bind(instance).call(interpreter, arguments);
      if (!result.ok) return result;
    }
    return ok(instance);
  }

  arity() {
    var initializer = this.findMethod("init");
    if (nil != initializer) return initializer.arity();
    return 0;
  }
}

class LoxInstance {
  init(klass) {
    this.klass = klass;
    this.fields = Map();
  }

  toString() {
    return this.klass.name + " instance";
  }

  get(name) {
    // FIXME: make Map handle nils as values.
    if (this.fields.get(name.lexeme) != nil) {
      return ok(this.fields.get(name.lexeme));
    }
    var method = this.klass.findMethod(name.lexeme);
    if (nil != method) return ok(method.bind(this));
    return err(RuntimeError(name, "Undefined property '" + name.lexeme + "'."));
  }

  set(name, value) {
    this.fields.set(name.lexeme, value);
  }
}

class Scanner {
  init(source) {
    this.source = source;
    this.tokens = List();
    this.start = 0;
    this.current = 0;
    this.line = 1;

    this.keywords = Map();
    this.keywords.set("and",    TT.AND);
    this.keywords.set("class",  TT.CLASS);
    this.keywords.set("else",   TT.ELSE);
    this.keywords.set("false",  TT.FALSE);
    this.keywords.set("for",    TT.FOR);
    this.keywords.set("fun",    TT.FUN);
    this.keywords.set("if",     TT.IF);
    this.keywords.set("nil",    TT.NIL);
    this.keywords.set("or",     TT.OR);
    this.keywords.set("print",  TT.PRINT);
    this.keywords.set("return", TT.RETURN);
    this.keywords.set("super",  TT.SUPER);
    this.keywords.set("this",   TT.THIS);
    this.keywords.set("true",   TT.TRUE);
    this.keywords.set("var",    TT.VAR);
    this.keywords.set("while",  TT.WHILE);

    this.DIGITS = Map();
    for (var i = 0; i < 10; i = i + 1) {
      this.DIGITS.set(str(i), true);
    }

    this.ALPHAS = Map();
    var ALPHASET = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_";
    for (var i = 0; i < strlen(ALPHASET); i = i + 1) {
      this.ALPHAS.set(strslice(ALPHASET, i, i + 1), true);
    }
  }

  scanTokens() {
    while (!this.isAtEnd()) {
      this.start = this.current;
      this.scanToken();
    }

    this.tokens.add(Token(TT.EOF, "", "\0", this.line));
    return this.tokens;
  }

  scanToken() {
    var c = this.advance();
    if (c == "(") { return this.addToken(TT.LEFT_PAREN); }
    if (c == ")") { return this.addToken(TT.RIGHT_PAREN); }
    if (c == "{") { return this.addToken(TT.LEFT_BRACE); }
    if (c == "}") { return this.addToken(TT.RIGHT_BRACE); }
    if (c == ",") { return this.addToken(TT.COMMA); }
    if (c == ".") { return this.addToken(TT.DOT); }
    if (c == "-") { return this.addToken(TT.MINUS); }
    if (c == "+") { return this.addToken(TT.PLUS); }
    if (c == ";") { return this.addToken(TT.SEMICOLON); }
    if (c == "*") { return this.addToken(TT.STAR); }
    if (c == "!") {
      if (this.match("=")) return this.addToken(TT.BANG_EQUAL);
      else return this.addToken(TT.BANG);
    }
    if (c == "=") {
      if (this.match("=")) return this.addToken(TT.EQUAL_EQUAL);
      else return this.addToken(TT.EQUAL);
    }
    if (c == "<") {
      if (this.match("=")) return this.addToken(TT.LESS_EQUAL);
      else return this.addToken(TT.LESS);
    }
    if (c == ">") {
      if (this.match("=")) return this.addToken(TT.GREATER_EQUAL);
      else return this.addToken(TT.GREATER);
    }
    if (c == "/") {
      if (this.match("/")) {
        while (this.peek() != "\n" and !this.isAtEnd()) this.advance();
        return;
      } else return this.addToken(TT.SLASH);
    }
    if (c == " " or c == "\r" or c == "\t") return;
    if (c == "\n") {
      this.line = this.line + 1;
      return;
    }
    if (c == "\"") return this.string();
    if (this.isDigit(c)) return this.number();
    if (this.isAlpha(c)) return this.identifier();
    LOX.error(this.line, "Unexpected character.");
    print(c);
  }

  identifier() {
    while (this.isAlphaNumeric(this.peek())) this.advance();

    var text = strslice(this.source, this.start, this.current);
    var type = this.keywords.get(text);
    if (nil == type) type = TT.IDENTIFIER;
    this.addToken(type);
  }

  string() {
    while (this.peek() != "\"" and !this.isAtEnd()) {
      if (this.peek() == "\n") this.line = this.line + 1;
      this.advance();
    }
    if (this.isAtEnd()) return LOX.error(this.line, "Unterminated string.");
    this.advance();
    var value = strslice(this.source, this.start + 1, this.current - 1);
    this.addTokenLiteral(TT.STRING, value);
  }

  number() {
    while (this.isDigit(this.peek())) this.advance();
    if (this.peek() == "." and this.isDigit(this.peekNext())) {
      this.advance();
      while (this.isDigit(this.peek())) this.advance();
    }
    this.addTokenLiteral(TT.NUMBER, parse_float(strslice(this.source, this.start, this.current)));
  }

  match(expected) {
    if (this.isAtEnd()) return false;
    if (strslice(this.source, this.current, this.current + 1) != expected) return false;
    this.current = this.current + 1;
    return true;
  }

  peek() {
    if (this.isAtEnd()) return "\0";
    return strslice(this.source, this.current, this.current + 1);
  }

  peekNext() {
    if (this.current + 1 >= strlen(this.source)) return "\0";
    return strslice(this.source, this.current + 1, this.current + 2);
  }

  isAlpha(c) {
    return !!this.ALPHAS.get(c);
  }

  isAlphaNumeric(c) {
    return this.isAlpha(c) or this.isDigit(c);
  }

  isDigit(c) {
    return !!this.DIGITS.get(str(c));
  }

  isAtEnd() {
    return this.current >= strlen(this.source);
  }

  advance() {
    this.current = this.current + 1;
    return strslice(this.source, this.current - 1, this.current);
  }

  addToken(type) {
    this.addTokenLiteral(type, nil);
  }

  addTokenLiteral(type, literal) {
    var text = strslice(this.source, this.start, this.current);
    this.tokens.add(Token(type, text, literal, this.line));
  }
}

class Parser {
  init(tokens) {
    this.tokens = tokens;
    this.current = 0;
  }

  parse() {
    var statements = List();
    while (!this.isAtEnd()) {
      var declaration = this.declaration();
      if (declaration.ok) statements.add(declaration.value);
    }
    return statements;
  }

  expression() {
    return this.assignment();
  }

  declaration() {
    if (this.match(TT.CLASS)) {
      var classDec = this.classDeclaration();
      if (classDec.ok) return classDec;
      else return ok(this.synchronize());
    }
    if (this.match(TT.FUN)) {
      var funDec = this.function("function");
      if (funDec.ok) return funDec;
      else return ok(this.synchronize());
    }
    if (this.match(TT.VAR)) {
      var varDec = this.varDeclaration();
      if (varDec.ok) return varDec;
      else return ok(this.synchronize());
    }
    var stmt = this.statement();
    if (stmt.ok) return stmt;
    else return ok(this.synchronize());
  }

  classDeclaration() {
    var name = this.consume(TT.IDENTIFIER, "Expect class name.");
    if (!name.ok) return name;
    name = name.value;
    var result = this.consume(TT.LEFT_BRACE, "Expect '{' before class body.");
    if (!result.ok) return result;

    var methods = List();
    while (!this.check(TT.RIGHT_BRACE) and !this.isAtEnd()) {
      var func = this.function("method");
      if (!func.ok) return func;
      methods.add(func.value);
    }

    this.consume(TT.RIGHT_BRACE, "Expect '}' after class body.");

    return ok(Class(name, methods));
  }

  statement() {
    if (this.match(TT.FOR)) return this.forStatement();
    if (this.match(TT.IF)) return this.ifStatement();
    if (this.match(TT.PRINT)) return this.printStatement();
    if (this.match(TT.RETURN)) return this.returnStatement();
    if (this.match(TT.WHILE)) return this.whileStatement();
    fun wrapStmts(statements) { return Block(statements); }
    if (this.match(TT.LEFT_BRACE)) return this.block().ifOk(wrapStmts);
    return this.expressionStatement();
  }

  forStatement() {
    var result = this.consume(TT.LEFT_PAREN, "Expect '(' after 'for'.");
    if (!result.ok) return result;

    var initializer;
    if (this.match(TT.SEMICOLON)) initializer = nil;
    else {
      if (this.match(TT.VAR)) {
        var varDec = this.varDeclaration();
        if (!varDec.ok) return varDec;
        initializer = varDec.value;
      } else {
        var expr = this.expressionStatement();
        if (!expr.ok) return expr;
        initializer = expr.value;
      }
    }

    var condition = nil;
    if (!this.check(TT.SEMICOLON)) {
      var expr = this.expression();
      if (!expr.ok) return expr;
      condition = expr.value;
    }
    result = this.consume(TT.SEMICOLON, "Expect ';' after loop condition.");
    if (!result.ok) return result;

    var increment = nil;
    if (!this.check(TT.RIGHT_PAREN)) {
      var expr = this.expression();
      if (!expr.ok) return expr;
      increment = expr.value;
    }
    result = this.consume(TT.RIGHT_PAREN, "Expect ')' after for.");
    if (!result.ok) return result;

    var body = this.statement();
    if (!body.ok) return body;
    body = body.value;

    // Desugar into While

    if (nil != increment) {
      var statements = List();
      statements.add(body);
      statements.add(Expression(increment));
      body = Block(statements);
    }

    if (nil == condition) condition = Literal(true);
    body = While(condition, body);

    if (nil != initializer) {
      var statements = List();
      statements.add(initializer);
      statements.add(body);
      body = Block(statements);
    }

    return ok(body);
  }

  ifStatement() {
    var result = this.consume(TT.LEFT_PAREN, "Expect '(' after 'if'.");
    if (!result.ok) return result;
    var condition = this.expression();
    if (!condition.ok) return condition;
    result = this.consume(TT.RIGHT_PAREN, "Expect ')' after if condition.");
    if (!result.ok) return result;

    var thenBranch = this.statement();
    if (!thenBranch.ok) return thenBranch;

    var elseBranch = nil;
    if (this.match(TT.ELSE)) {
      var branch = this.statement();
      if (!branch.ok) return branch;
      elseBranch = branch.value;
    }

    return ok(If(condition.value, thenBranch.value, elseBranch));
  }

  printStatement() {
    var value = this.expression();
    if (!value.ok) return value;
    var result = this.consume(TT.SEMICOLON, "Expect ';' after value.");
    if (!result.ok) return result;
    return ok(Print(value.value));
  }

  returnStatement() {
    var keyword = this.previous();
    var value = nil;
    if (!this.check(TT.SEMICOLON)) {
      var expr = this.expression();
      if (!expr.ok) return expr;
      value = expr.value;
    }
    var result = this.consume(TT.SEMICOLON, "Expect ';' after return value.");
    if (!result.ok) return result;
    return ok(Return(keyword, value));
  }

  varDeclaration() {
    var name = this.consume(TT.IDENTIFIER, "Expect variable name.");
    if (!name.ok) return name;
    var initializer = nil;
    if (this.match(TT.EQUAL)) {
      var expression = this.expression();
      if (!expression.ok) return expression;
      initializer = expression.value;
    }
    var result = this.consume(TT.SEMICOLON, "Expect ';' after variable declaration.");
    if (!result.ok) return result;
    return ok(Var(name.value, initializer));
  }

  whileStatement() {
    var result = this.consume(TT.LEFT_PAREN, "Expect '(' after 'while'.");
    if (!result.ok) return result;
    var condition = this.expression();
    if (!condition.ok) return condition;
    result = this.consume(TT.RIGHT_PAREN, "Expect ')' after condition.");
    if (!result.ok) return result;
    var body = this.statement();
    if (!body.ok) return body;
    return ok(While(condition.value, body.value));
  }

  expressionStatement() {
    var expr = this.expression();
    if (!expr.ok) return expr;
    var result = this.consume(TT.SEMICOLON, "Expect ';' after expression.");
    if (!result.ok) return result;
    return ok(Expression(expr.value));
  }

  function(kind) {
    var name = this.consume(TT.IDENTIFIER, "Expect " + kind + " name.");
    if (!name.ok) return name; else name = name.value;

    var result = this.consume(TT.LEFT_PAREN, "Expect '(' after " + kind + " name.");
    if (!result.ok) return result;

    var parameters = List();
    if (!this.check(TT.RIGHT_PAREN)) {
      var name = this.consume(TT.IDENTIFIER, "Expect parameter name.");
      if (!name.ok) return name;
      parameters.add(name.value);

      while (this.match(TT.COMMA)) {
        if (parameters.size() > 255) this.error(this.previous(), "Can't have more than 255 parameters.");

        var name = this.consume(TT.IDENTIFIER, "Expect parameter name.");
        if (!name.ok) return name;
        parameters.add(name.value);
      }
    }

    result = this.consume(TT.RIGHT_PAREN, "Expect ')' after parameters.");
    if (!result.ok) return result;

    result = this.consume(TT.LEFT_BRACE, "Expect '{' before " + kind + " body.");
    if (!result.ok) return result;
    var body = this.block();
    if (!body.ok) return body;
    return ok(Function(name, parameters, body.value));
  }

  block() {
    var statements = List();
    while (!this.check(TT.RIGHT_BRACE) and !this.isAtEnd()) {
      var decl = this.declaration();
      if (!decl.ok) return decl;
      if (nil != decl.value) statements.add(decl.value);
    }
    var result = this.consume(TT.RIGHT_BRACE, "Expect '}' after block.");
    if (!result.ok) return result;
    return ok(statements);
  }

  blockStatement() {
    // var statements = this.block();
    // if (!statements.ok) 
    var statements = List();
    while (!this.check(TT.RIGHT_BRACE) and !this.isAtEnd()) {
      var decl = this.declaration();
      if (!decl.ok) return decl;
      if (nil != decl.value) statements.add(decl.value);
    }
    var result = this.consume(TT.RIGHT_BRACE, "Expect '}' after block.");
    if (!result.ok) return result;
    return ok(Block(statements));
  }

  assignment() {
    var expr = this.orClause();
    if (!expr.ok) return expr;
    expr = expr;

    if (this.match(TT.EQUAL))  {
      var equals = this.previous();
      var value = this.assignment();
      if (!value.ok) return value;

      if (expr.value.getClassName() == "Variable") {
        var name = expr.name;
        return ok(Assign(name, value.value));
      } else {
        if (str(expr.value) == "Get instance") {
          return ok(Set(expr.value.object, expr.value.name, value.value));
        } else {
          this.error(equals, "Invalid assignment target.");
        }
      }
    }
    return expr;
  }

  orClause() {
    var expr = this.andClause();
    if (!expr.ok) return expr;
    expr = expr.value;

    while (this.match(TT.OR)) {
      var operator = this.previous();
      var right = this.andClause();
      if (!right.ok) return right;
      expr = Logical(expr, operator, right.value);
    }
    return ok(expr);
  }

  andClause() {
    var expr = this.equality();
    if (!expr.ok) return expr;
    expr = expr.value;

    while (this.match(TT.AND)) {
      var operator = this.previous();
      var right = this.equality();
      if (!right.ok) return right;
      expr = Logical(expr, operator, right.value);
    }
    return ok(expr);
  }

  equality() {
    var expr = this.comparison();
    if (!expr.ok) return expr;
    expr = expr.value;
    while (this.match(TT.BANG_EQUAL) or this.match(TT.EQUAL_EQUAL)) {
      var operator = this.previous();
      var right = this.comparison();
      if (!right.ok) return right;
      expr = Binary(expr, operator, right.value);
    }
    return ok(expr);
  }

  comparison() {
    var expr = this.term();
    if (!expr.ok) return expr;
    expr = expr.value;
    while (this.match(TT.GREATER)
        or this.match(TT.GREATER_EQUAL)
        or this.match(TT.LESS)
        or this.match(TT.LESS_EQUAL)) {
      var operator = this.previous();
      var right = this.term();
      if (!right.ok) return right;
      expr = Binary(expr, operator, right.value);
    }
    return ok(expr);
  }

  term() {
    var expr = this.factor();
    if (!expr.ok) return expr;
    expr = expr.value;
    while (this.match(TT.MINUS) or this.match(TT.PLUS)) {
      var operator = this.previous();
      var right = this.factor();
      if (!right.ok) return right;
      expr = Binary(expr, operator, right.value);
    }
    return ok(expr);
  }

  factor() {
    var expr = this.unary();
    if (!expr.ok) return expr;
    expr = expr.value;
    while (this.match(TT.SLASH) or this.match(TT.STAR)) {
      var operator = this.previous();
      var right = this.unary();
      if (!right.ok) return right;
      expr = Binary(expr, operator, right.value);
    }
    return ok(expr);
  }

  unary() {
    while (this.match(TT.BANG) or this.match(TT.MINUS)) {
      var operator = this.previous();
      var right = this.unary();
      if (!right.ok) return right;
      return ok(Unary(operator, right.value));
    }
    return this.call();
  }

  finishCall(callee) {
    var arguments = List();

    if (!this.check(TT.RIGHT_PAREN)) {
      var expr = this.expression();
      if (!expr.ok) return expr;
      arguments.add(expr.value);

      while (this.match(TT.COMMA)) {
        if (arguments.size() >= 255) {
          this.error(this.previous(), "Can't have more than 255 arguments.");
        }
        var expr = this.expression();
        if (!expr.ok) return expr;
        arguments.add(expr.value);
      }
    }

    var paren = this.consume(TT.RIGHT_PAREN, "Expect ')' after arguments.");
    if (!paren.ok) return paren;
    return ok(Call(callee, paren.value, arguments));
  }

  call() {
    var expr = this.primary();
    if (!expr.ok) return expr;
    expr = expr.value;

    while (true) {
      if (this.match(TT.LEFT_PAREN)) {
        var result = this.finishCall(expr);
        if (!result.ok) return result;
        expr = result.value;
      } else {
        if (this.match(TT.DOT)) {
          var name = this.consume(TT.IDENTIFIER, "Expect property name after '.'.");
          if (!name.ok) return name;
          expr = Get(expr, name.value);

        } else {
          return ok(expr);
        }
      }
    }

    // while (this.match(TT.LEFT_PAREN)) {
    //   var result = this.finishCall(expr);
    //   if (!result.ok) return result;
    //   expr = result.value;
    // }

    // return ok(expr);
  }

  primary() {
    if (this.match(TT.FALSE)) return ok(Literal(false));
    if (this.match(TT.TRUE)) return ok(Literal(true));
    if (this.match(TT.NIL)) return ok(Literal(nil));
    if (this.match(TT.NUMBER) or this.match(TT.STRING)) return ok(Literal(this.previous().literal));
    if (this.match(TT.THIS)) return ok(This(this.previous()));
    if (this.match(TT.IDENTIFIER)) return ok(Variable(this.previous()));
    if (this.match(TT.LEFT_PAREN)) {
      var expr = this.expression();
      if (!expr.ok) return expr;
      var result = this.consume(TT.RIGHT_PAREN, "Expect ')' after expression.");
      if (!result.ok) return result;
      return ok(Grouping(expr.value));
    }
    return err(this.error(this.peek(), "Expect expression."));
  }

  match(type) {
    if (this.check(type)) {
      this.advance();
      return true;
    }
    return false;
  }

  // NOTE! returns Result
  consume(type, message) {
    if (this.check(type)) return ok(this.advance());
    return err(this.error(this.peek(), message));
  }

  check(type) {
    if (this.isAtEnd()) return false;
    return this.peek().type == type;
  }

  advance() {
    if (!this.isAtEnd()) this.current = this.current + 1;
    return this.previous();
  }

  isAtEnd() {
    return this.peek().type == TT.EOF;
  }

  peek() {
    return this.tokens.get(this.current);
  }

  previous() {
    return this.tokens.get(this.current - 1);
  }

  error(token, message) {
    LOX.errorToken(token, message);
    return ParseError();
  }

  synchronize() {
    this.advance();
    while (!this.isAtEnd()) {
      if (this.previous().type == TT.SEMICOLON) return;
      var type = this.peek().type;
      if (type == TT.CLASS
        or type == TT.FUN
        or type == TT.VAR
        or type == TT.FOR
        or type == TT.IF
        or type == TT.WHILE
        or type == TT.PRINT
        or type == TT.RETURN) return;
      this.advance();
    }
  }
}

var FunctionType = Object();
FunctionType.NONE = "NONE";
FunctionType.FUNCTION = "FUNCTION";
FunctionType.INITIALIZER = "INITIALIZER";
FunctionType.METHOD = "METHOD";

var ClassType = Object();
ClassType.NONE = "NONE";
ClassType.CLASS = "CLASS";

class Resolver < Visitor {
  init(interpreter) {
    this.interpreter = interpreter;
    this.scopes = List();
    this.currentFunction = FunctionType.NONE;
    this.currentClass = ClassType.NONE;
  }

  visitBlockStmt(stmt) {
    this.beginScope();
    this.resolveStmts(stmt.statements);
    this.endScope();
  }

  visitClassStmt(stmt) {
    var enclosingClass = this.currentClass;
    this.currentClass = ClassType.CLASS;

    this.declare(stmt.name);
    this.define(stmt.name);

    this.beginScope();
    this.scopes.peek().set("this", true);

    for (var i = 0; i < stmt.methods.size(); i = i + 1) {
      var method = stmt.methods.get(i);
      var declaration = FunctionType.METHOD;
      if (method.name.lexeme == "init") declaration = FunctionType.INITIALIZER;
      this.resolveFunction(method, declaration);
    }

    this.endScope();
    this.currentClass = enclosingClass;
  }

  visitExpressionStmt(stmt) {
    this.resolve(stmt.expression);
  }

  visitFunctionStmt(stmt) {
    this.declare(stmt.name);
    this.define(stmt.name);
    this.resolveFunction(stmt, FunctionType.FUNCTION);
  }

  visitIfStmt(stmt) {
    this.resolve(stmt.condition);
    this.resolve(stmt.thenBranch);
    if (nil != stmt.elseBranch) this.resolve(stmt.elseBranch);
  }

  visitPrintStmt(stmt) {
    this.resolve(stmt.expression);
  }

  visitReturnStmt(stmt) {
    if (this.currentFunction == FunctionType.NONE)
      LOX.errorToken(stmt.keyword, "Can't return from top-level code.");

    if (nil != stmt.value) {
      if (this.currentFunction == FunctionType.INITIALIZER) {
        LOX.errorToken(stmt.keyword, "Can't return a value from an initializer.");
      }
      this.resolve(stmt.value);
    }
  }

  visitVarStmt(stmt) {
    this.declare(stmt.name);
    if (nil != stmt.initializer) this.resolve(stmt.initializer);
    this.define(stmt.name);
  }

  visitWhileStmt(stmt) {
    this.resolve(stmt.condition);
    this.resolve(stmt.body);
  }

  visitAssignExpr(expr) {
    this.resolve(expr.value);
    this.resolveLocal(expr, expr.name);
  }

  visitBinaryExpr(expr) {
    this.resolve(expr.left);
    this.resolve(expr.right);
  }

  visitCallExpr(expr) {
    this.resolve(expr.callee);
    for (var i = 0; i < expr.arguments.size(); i = i + 1) {
      this.resolve(expr.arguments.get(i));
    }
  }

  visitGetExpr(expr) {
    this.resolve(expr.object);
  }

  visitGroupingExpr(expr) {
    this.resolve(expr.expression);
  }

  visitLiteralExpr(expr) {
    // Nothing to do here.
  }

  visitLogicalExpr(expr) {
    this.resolve(expr.left);
    this.resolve(expr.right);
  }

  visitSetExpr(expr) {
    this.resolve(expr.value);
    this.resolve(expr.object);
  }

  visitThisExpr(expr) {
    if (ClassType.NONE == this.currentClass) {
      LOX.errorToken(expr.keyword, "Can't use 'this' outside of a class.");
      return;
    }
    this.resolveLocal(expr, expr.keyword);
  }

  visitUnaryExpr(expr) {
    this.resolve(expr.right);
  }

  visitVariableExpr(expr) {
    if (!this.scopes.isEmpty() and this.scopes.peek().get(expr.name.lexeme) == false) {
      LOX.errorToken(expr.name, "Can't read local variable in its own initializer.");
    }
    this.resolveLocal(expr, expr.name);
  }

  resolveStmts(statements) {
    statements.forEach(this.resolve);
  }

  resolve(stmt) {
    stmt.accept(this);
  }

  resolveFunction(function, type) {
    var enclosingFunction = this.currentFunction;
    this.currentFunction = type;
    this.beginScope();
    for (var i = 0; i < function.params.size(); i = i + 1) {
      this.declare(function.params.get(i));
      this.define(function.params.get(i));
    }
    this.resolveStmts(function.body);
    this.endScope();
    this.currentFunction = enclosingFunction;
  }

  beginScope() {
    this.scopes.push(Map());
  }

  endScope() {
    this.scopes.pop();
  }

  declare(name) {
    if (this.scopes.isEmpty()) return;
    var scope = this.scopes.peek();
    if (nil != scope.get(name.lexeme)) LOX.errorToken(name, "Already a variable with this name in this scope.");
    scope.set(name.lexeme, false);
  }

  define(name) {
    if (this.scopes.isEmpty()) return;
    this.scopes.peek().set(name.lexeme, true);
  }

  resolveLocal(expr, name) {
    for (var i = this.scopes.size() - 1; i >= 0; i = i - 1) {
      if (nil != this.scopes.get(i).get(name.lexeme)) {
        this.interpreter.resolve(expr, this.scopes.size() - 1 - i);
        return;
      }
    }
  }
}

class Interpreter < Visitor {
  init() {
    this.DIGITS = Map();
    for (var i = 0; i < 10; i = i + 1) this.DIGITS.set(str(i), true);
    this.globals = Environment(nil);
    this.environment = this.globals;
    this.locals = Map();

    class RtClock < LoxCallable {
      arity() { return 0; }
      call(interpreter, arguments) { return clock(); }
      toString() { return "<native fn>"; }
    }
    this.globals.define("clock", RtClock());
  }

  interpret(statements) {
    for (var i = 0; i < statements.size(); i = i + 1) {
      var result = this.execute(statements.get(i));
      if (!result.ok) return LOX.runtimeError(result.value);
    }
  }

  evaluate(expr) {
    return expr.accept(this);
  }

  execute(stmt) {
    return stmt.accept(this);
  }

  resolve(expr, depth) {
    this.locals.set(expr, depth);
  }

  executeBlock(statements, environment) {
    var previous = this.environment;
    this.environment = environment;
    for (var i = 0; i < statements.size(); i = i + 1) {
      var result = this.execute(statements.get(i));
      if (!result.ok) {
        this.environment = previous;
        return result;
      }
    }
    this.environment = previous;
    return ok(nil);
  }

  visitBlockStmt(stmt) {
    return this.executeBlock(stmt.statements, Environment(this.environment));
  }

  visitClassStmt(stmt) {
    this.environment.define(stmt.name.lexeme, nil);
    var methods = Map();
    for (var i = 0; i < stmt.methods.size(); i = i + 1) {
      var method = stmt.methods.get(i);
      var function = LoxFunction(method, this.environment, method.name.lexeme == "init");
      methods.set(method.name.lexeme, function);
    }

    var klass = LoxClass(stmt.name.lexeme, methods);
    return this.environment.assign(stmt.name, klass);
  }

  visitExpressionStmt(stmt) {
    return this.evaluate(stmt.expression);
  }

  visitFunctionStmt(stmt) {
    var function = LoxFunction(stmt, this.environment, false);
    this.environment.define(stmt.name.lexeme, function);
    return ok(nil);
  }

  visitIfStmt(stmt) {
    var condition = this.evaluate(stmt.condition);
    if (!condition.ok) return condition;
    if (this.isTruthy(condition.value)) return this.execute(stmt.thenBranch);
    if (stmt.elseBranch != nil) return this.execute(stmt.elseBranch);
    return ok(nil);
  }

  visitPrintStmt(stmt) {
    var value = this.evaluate(stmt.expression);
    if (!value.ok) return value;
    print(this.stringify(value.value));
    return ok(nil);
  }

  visitReturnStmt(stmt) {
    var value = nil;
    if (nil != stmt.value) {
      var result = this.evaluate(stmt.value);
      if (!result.ok) return result;
      value = result.value;
    }
    return err(ReturnState(value));
  }

  visitVarStmt(stmt) {
    var value = nil;
    if (nil != stmt.initializer) {
      var result = this.evaluate(stmt.initializer);
      if (!result.ok) return result;
      value = result.value;
    }
    this.environment.define(stmt.name.lexeme, value);
    return ok(nil);
  }

  visitWhileStmt(stmt) {
    var condition = this.evaluate(stmt.condition);
    if (!condition.ok) return condition; else condition = condition.value;
    while (this.isTruthy(condition)) {
      var result = this.execute(stmt.body);
      if (!result.ok) return result;
      condition = this.evaluate(stmt.condition);
      if (!condition.ok) return condition; else condition = condition.value;
    }
    return ok(nil);
  }

  visitAssignExpr(expr) {
    var value = this.evaluate(expr.value);
    if (!value.ok) return value;

    var distance = this.locals.get(expr);
    if (distance != nil) {
      var result = this.environment.assignAt(distance, expr.name, value.value);
      if (!result.ok) return result;
    } else {
      var result = this.globals.assign(expr.name, value.value);
      if (!result.ok) return result;
    }
    // var result = this.environment.assign(expr.name, value.value);
    // if (!result.ok) return result;
    return value;
  }

  visitBinaryExpr(expr) {
    var left = this.evaluate(expr.left);
    if (!left.ok) return left;
    var right = this.evaluate(expr.right);
    if (!right.ok) return right;

    if (expr.operator.type == TT.BANG_EQUAL) {
      return ok(!this.isEqual(left.value, right.value));
    }
    if (expr.operator.type == TT.EQUAL_EQUAL) {
      return ok(this.isEqual(left.value, right.value));
    }

    if (expr.operator.type == TT.GREATER) {
      var res = this.checkNumberOperands(expr.operator, left.value, right.value);
      if (!res.ok) return res;
      return ok(left.value > right.value);
    }
    if (expr.operator.type == TT.GREATER_EQUAL) {
      var res = this.checkNumberOperands(expr.operator, left.value, right.value);
      if (!res.ok) return res;
      return ok(left.value >= right.value);
    }
    if (expr.operator.type == TT.LESS) {
      var res = this.checkNumberOperands(expr.operator, left.value, right.value);
      if (!res.ok) return res;
      return ok(left.value < right.value);
    }
    if (expr.operator.type == TT.LESS_EQUAL) {
      var res = this.checkNumberOperands(expr.operator, left.value, right.value);
      if (!res.ok) return res;
      return ok(left.value <= right.value);
    }

    if (expr.operator.type == TT.MINUS) {
      var res = this.checkNumberOperands(expr.operator, left.value, right.value);
      if (!res.ok) return res;
      return ok(left.value - right.value);
    }
    if (expr.operator.type == TT.SLASH) {
      var res = this.checkNumberOperands(expr.operator, left.value, right.value);
      if (!res.ok) return res;
      return ok(left.value / right.value);
    }
    if (expr.operator.type == TT.STAR) {
      var res = this.checkNumberOperands(expr.operator, left.value, right.value);
      if (!res.ok) return res;
      return ok(left.value * right.value);
    }
    if (expr.operator.type == TT.PLUS) {
      if (this.isNumber(left.value) and this.isNumber(right.value)) {
        return ok(left.value + right.value);
      }
      if (this.isString(left.value) and this.isString(right.value)) {
        return ok(left.value + right.value);
      }
      return err(RuntimeError(expr.operator, "Operands must be two numbers or two strings."));
    }
    // Unreachable.
    return err(nil);
  }

  visitCallExpr(expr) {
    var callee = this.evaluate(expr.callee);
    if (!callee.ok) return callee; else callee = callee.value;

    var arguments = List();
    for (var i = 0; i < expr.arguments.size(); i = i + 1) {
      var argument = this.evaluate(expr.arguments.get(i));
      if (!argument.ok) return argument;
      arguments.add(argument.value);
    }

    if (callee.("isCallable") == nil) return err(RuntimeError(expr.paren, "Can only call functions and classes."));

    return callee.call(this, arguments);
  }

  visitGetExpr(expr) {
    var object = this.evaluate(expr.object);
    if (!object.ok) return object;
    // FIXME type check
    if (str(object.value) == "LoxInstance instance") {
      return object.value.get(expr.name);
    }
    return err(RuntimeError(expr.name, "Only instances have properties."));
  }

  visitGroupingExpr(expr) {
    return this.evaluate(expr.expression);
  }

  visitLiteralExpr(expr) {
    return ok(expr.value);
  }

  visitLogicalExpr(expr) {
    var left = this.evaluate(expr.left);
    if (!left.ok) return left;
    if (expr.operator.type == TT.OR) {
      if (this.isTruthy(left.value)) return ok(left.value);
    } else { // else AND
      if (!this.isTruthy(left.value)) return ok(left.value);
    }
    return this.evaluate(expr.right);
  }

  visitSetExpr(expr) {
    var object = this.evaluate(expr.object);
    if (!object.ok) return object;
    object = object.value;

    if (!(str(object) == "LoxInstance instance")) {
      return err(RuntimeError(expr.name, "Only instances have fields."));
    }

    var value = this.evaluate(expr.value);
    if (!value.ok) return value;
    object.set(expr.name, value.value);
    return value;
  }

  visitThisExpr(expr) {
    return this.lookupVariable(expr.keyword, expr);
  }

  visitUnaryExpr(expr) {
    var right = this.evaluate(expr.right);
    if (!right.ok) return right;
    if (expr.operator.type == TT.BANG) return ok(!this.isTruthy(right.value));
    if (expr.operator.type == TT.MINUS) {
      var res = this.checkNumberOperand(expr.operator, right.value);
      if (!res.ok) return res;
      return ok(-right.value);
    }

    // Unreachable.
    return err(nil);
  }

  visitVariableExpr(expr) {
    return this.lookupVariable(expr.name, expr);
    // return this.environment.get(expr.name);
  }

  lookupVariable(name, expr) {
    var distance = this.locals.get(expr);
    if (nil != distance) {
      return this.environment.getAt(distance, name.lexeme);
    } else {
      return this.globals.get(name);
    }
  }

  checkNumberOperand(operator, operand) {
    if (this.isNumber(operand)) return ok(nil);
    return err(RuntimeError(operator, "Operand must be a number."));
  }

  checkNumberOperands(operator, left, right) {
    if (this.isNumber(left) and this.isNumber(right)) return ok(nil);
    return err(RuntimeError(operator, "Operands must be numbers."));
  }

  isString(value) {
    return value == str(value);
  }

  isNumber(value) {
    var potential = str(value);
    var seenDot = false;
    var seenDigit = false;
    for (var i = 0; i < strlen(potential); i = i + 1) {
      var digit = strslice(potential, i, i + 1);
      if (!(digit == "-" and i == 0)) {
        if (digit == ".") {
          if (seenDot) return false;
          seenDot = true;
        } else {
          var isDigit = !!this.DIGITS.get(digit);
          if (!isDigit) return false;
          seenDigit = true;
        }
      }
    }
    return seenDigit;
  }

  isTruthy(object) {
    if (nil == object) return false;
    if (false == object) return false;
    return true;
  }

  isEqual(a, b) {
    if (nil == a and nil == b) return true;
    if (nil == a) return false;
    return a == b;
  }

  stringify(object) {
    if (nil == object) return "nil";
    if (this.isNumber(object)) return str(object);
    return str(object);
  }
}

var INTERPRETER = Interpreter();

fun run(source) {
  var scanner = Scanner(source);
  var tokens = scanner.scanTokens();
  var parser = Parser(tokens);
  var statements = parser.parse();

  if (LOX.hadError) return;

  var resolver = Resolver(INTERPRETER);
  resolver.resolveStmts(statements);

  if (LOX.hadError) return;

  INTERPRETER.interpret(statements);
}

fun runFile(filename) {
  var source = readfile(filename);
  run(source);

  if (LOX.hadError) process_exit(65);
  if (LOX.hadRuntimeError) process_exit(70);
}

{
  var args = process_args();
  if (args.count > 1) {
    print("Usage: loxlox [script]");
  } else if (args.count == 1) {
    runFile(args.(0));
  } else {
    print("Prompt not implemented.");
  }
}
